from pydantic import BaseModel, Field, field_validator
from typing import List, Literal, Optional
from datetime import datetime, timezone


### API Request Models
class AnalysisRequest(BaseModel):
    """Request model for starting a new analysis."""
    query: str = Field(..., min_length=2, description="The primary topic or product to analyze")

class ComparisonRequest(BaseModel):
    """Request model for comparing multiple products."""
    Products: List[str] = Field(..., min_length=2, description="List of products to compare")
    time_range: Literal['1h','24h','7d'] = Field('24h', description="Time range for the Comparison")

### API Response Models
class StartResponse(BaseModel):
    """Response model for starting an analysis."""
    status: str
    query: str
    message: Optional[str] = None

class SentimentData(BaseModel):
    """Data model for sentiment distribution (positive, negative, neutral)."""
    positive: int = 0
    negative: int = 0
    neutral: int = 0

class TrendData(BaseModel):
    """Data model for a single point in sentiment trend over time."""
    timestamp: str
    positive: int
    negative: int
    neutral: int

class SummaryData(BaseModel):
    """Structured summary data generated by the LLM."""
    overview: str = Field(..., description="A brief, high-level overview of the sentiment.")
    keyInsights: List[str] = Field(..., description="Bulleted list of key findings or recurring themes.")
    overallSentiment: Literal['positive', 'negative', 'neutral'] = Field(..., description="The general sentiment trend observed.")

class SummaryResponse(BaseModel):
    """Response model containing positive and negative summaries."""
    positive_summary: SummaryData
    negative_summary: SummaryData

class FeedItem(BaseModel):
    """Data model for a single feed item returned to the client."""
    id: str = Field(..., alias='_id')
    text: str
    sentiment: Optional[Literal['positive', 'negative', 'neutral']] = None
    score: Optional[float] = None
    timestamp: datetime
    source: str
    query: str

class WordCloudData(BaseModel):
    """Data model for a single word in the word cloud."""
    text: str
    value: int

class ProductTrend(BaseModel):
    """Contains the sentiment trend data for a specific product."""
    product_name: str
    trends: List[TrendData]
class CompetitorComparisonResponse(BaseModel):
    """Response model for the competitor comparison endpoint."""
    comparison: List[ProductTrend]


### Model Structures for LLMs ###
class AspectSentiment(BaseModel):
    """Model for aspect-based sentiment analysis."""
    aspect: str = Field(..., description="The specific feature or topic being discussed.")
    sentiment: Literal['positive', 'negative', 'neutral'] = Field(..., description="The sentiment towards this aspect.")
    quote: str = Field(..., description="A short verbatim quote from the text supporting the sentiment.")

    @field_validator('sentiment', mode='before')
    @classmethod
    def  to_lowercase(cls, v: str) -> str:
        return v.lower()

class AnalysisResult(BaseModel):
    """Detailed analysis result from the LLM for a single text document."""
    sentiment: Literal['positive', 'negative', 'neutral']
    score: float
    emotions: List[str] = Field(default_factory=list)
    intent: str = Field("unknown")
    aspects: List[AspectSentiment] = Field(default_factory=list)

    @field_validator('sentiment', mode='before')
    @classmethod
    def to_lowercase(cls, v: str) -> str:
        return v.lower()

### Database Model ###
class SentimentRecord(BaseModel):
    """The main schema for documents stored in the MongoDB collection."""
    query: str
    text: str
    source: str
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    analysis: AnalysisResult

    class config:
        allow_population_by_field_name = True
        json_encoders = {
            datetime: lambda dt: dt.isoformat()
        }